#include "stdafx.h"
#include "dll_inject.h"
#include "logger.h"

extern HINSTANCE g_hDllInst;

namespace
{
#define PRE_X32SHELLCODE_ARGS_3_TO_1 \
	"\x58"         /* pop eax   */ \
	"\x59"         /* pop ecx   */ \
	"\x83\xC4\x08" /* add esp,8 */ \
	"\x51"         /* push ecx  */ \
	"\x50"         /* push eax  */

#define PRE_X32SHELLCODE_VIRTUAL_FREE \
	"\xFF\x74\x24\x04"     /* push dword ptr ss:[esp+4]    */ \
	"\xE8\x23\x00\x00\x00" /* call $+23                    */ \
	"\x8B\x4C\x24\x04"     /* mov ecx,dword ptr ss:[esp+4] */ \
	"\x36\x8B\x09"         /* mov ecx,dword ptr ss:[ecx]   */ \
	"\x85\xC9"             /* test ecx,ecx                 */ \
	"\x75\x03"             /* jne $+3                      */ \
	"\xC2\x04\x00"         /* ret 4                        */ \
	"\x58"                 /* pop eax                      */ \
	"\x5A"                 /* pop edx                      */ \
	"\x68\x00\x80\x00\x00" /* push 8000                    */ \
	"\x6A\x00"             /* push 0                       */ \
	"\xE8\x00\x00\x00\x00" /* call $                       */ \
	"\x83\x2C\x24\x25"     /* sub dword ptr ss:[esp],25    */ \
	"\x50"                 /* push eax                     */ \
	"\xFF\xE1"             /* jmp ecx                      */

	// The 32-bit InjectShellcode function from the project in the inject-shellcode subfolder.
	const BYTE x32APCShellcode[] =
		PRE_X32SHELLCODE_ARGS_3_TO_1
		PRE_X32SHELLCODE_VIRTUAL_FREE
		"\x55\x8B\xEC\x81\xEC\x88\x00\x00\x00\x64\xA1\x30\x00\x00\x00\x33\xC9\xC7\x45\xA8\x49\x6E\x6A\x65\x33\xD2\xC7\x45\xAC\x63\x74\x49"
		"\x6E\x66\xC7\x45\xB0\x69\x74\xC6\x45\xB2\x00\x8B\x40\x0C\x53\x83\xC0\x14\xC7\x45\x84\x00\x00\x00\x00\x56\x57\x33\xDB\xC7\x45\xE0"
		"\x00\x00\x00\x00\x8B\x30\x33\xFF\xC7\x45\xDC\x00\x00\x00\x00\x89\x55\xEC\x89\x4D\xF8\x89\x5D\xF4\x89\x7D\xFC\x89\x4D\xD8\x89\x45"
		"\x80\x89\x75\xE4\x3B\xF0\x0F\x84\xBE\x01\x00\x00\x8D\x64\x24\x00\x8B\x45\xE4\x33\xC9\x8B\x76\x28\x0F\xB7\x50\x24\x8D\x64\x24\x00"
		"\x0F\xB6\x3E\xC1\xC9\x0D\x80\x3E\x61\x72\x03\x83\xC1\xE0\x81\xC2\xFF\xFF\x00\x00\x03\xCF\x46\x66\x85\xD2\x75\xE4\x81\xF9\x5B\xBC"
		"\x4A\x6A\x0F\x85\x3D\x01\x00\x00\x8B\x45\xE4\xBB\x08\x00\x00\x00\x8B\x70\x10\x8B\x46\x3C\x8B\x54\x30\x78\x8B\x44\x32\x20\x03\xD6"
		"\x03\xC6\x89\x95\x7C\xFF\xFF\xFF\x89\x45\xE8\x8B\x4A\x24\x8B\x7A\x18\x03\xCE\x89\x4D\xF0\x85\xFF\x0F\x84\x04\x01\x00\x00\x8B\x10"
		"\x03\xD6\x33\xC0\x8A\x0A\xC1\xC8\x0D\x8D\x52\x01\x0F\xBE\xC9\x03\xC1\x8A\x0A\x84\xC9\x75\xEF\x3D\xA4\x4E\x0E\xEC\x74\x35\x3D\xAA"
		"\xFC\x0D\x7C\x74\x2E\x3D\xA0\xD5\xC9\x4D\x74\x27\x3D\xAC\x33\x06\x03\x74\x20\x3D\x66\x19\xDA\x75\x74\x19\x3D\xBC\x22\x0D\x47\x74"
		"\x12\x3D\xFB\x97\xFD\x0F\x74\x0B\x3D\x7C\xC4\x22\x59\x0F\x85\x98\x00\x00\x00\x8B\x4D\xF0\x0F\xB7\x11\x8B\x8D\x7C\xFF\xFF\xFF\x8B"
		"\x49\x1C\x8D\x0C\x91\x03\xCE\x3D\xA4\x4E\x0E\xEC\x75\x09\x8B\x01\x03\xC6\x89\x45\x84\xEB\x6E\x3D\xAA\xFC\x0D\x7C\x75\x09\x8B\x01"
		"\x03\xC6\x89\x45\xE0\xEB\x5E\x3D\xA0\xD5\xC9\x4D\x75\x09\x8B\x01\x03\xC6\x89\x45\xDC\xEB\x4E\x3D\xAC\x33\x06\x03\x75\x09\x8B\x01"
		"\x03\xC6\x89\x45\xEC\xEB\x3E\x3D\x66\x19\xDA\x75\x75\x09\x8B\x01\x03\xC6\x89\x45\xF8\xEB\x2E\x3D\xBC\x22\x0D\x47\x75\x09\x8B\x01"
		"\x03\xC6\x89\x45\xF4\xEB\x1E\x3D\xFB\x97\xFD\x0F\x75\x09\x8B\x01\x03\xC6\x89\x45\xFC\xEB\x0E\x3D\x7C\xC4\x22\x59\x75\x07\x8B\x01"
		"\x03\xC6\x89\x45\xD8\x81\xC3\xFF\xFF\x00\x00\x8B\x45\xE8\x4F\x83\x45\xF0\x02\x83\xC0\x04\x89\x45\xE8\x66\x85\xDB\x0F\x85\xF4\xFE"
		"\xFF\xFF\x8B\x5D\xF4\x8B\x45\x84\x8B\x55\xEC\x8B\x4D\xF8\x8B\x7D\xFC\x85\xC0\x74\x22\x83\x7D\xE0\x00\x74\x1C\x83\x7D\xDC\x00\x74"
		"\x16\x85\xD2\x74\x12\x85\xC9\x74\x0E\x85\xDB\x74\x0A\x85\xFF\x74\x06\x83\x7D\xD8\x00\x75\x15\x8B\x75\xE4\x8B\x36\x89\x75\xE4\x3B"
		"\x75\x80\x0F\x85\x48\xFE\xFF\xFF\xEB\x02\x33\xC0\x8B\x75\x08\x89\x16\x85\xC0\x0F\x84\x48\x02\x00\x00\x83\x7D\xE0\x00\x0F\x84\x3E"
		"\x02\x00\x00\x83\x7D\xDC\x00\x0F\x84\x34\x02\x00\x00\x85\xD2\x0F\x84\x2C\x02\x00\x00\x85\xC9\x0F\x84\x24\x02\x00\x00\x85\xDB\x0F"
		"\x84\x1C\x02\x00\x00\x85\xFF\x0F\x84\x14\x02\x00\x00\x8B\x45\xD8\x85\xC0\x0F\x84\x09\x02\x00\x00\x8B\x7E\x08\x8D\x8D\x78\xFF\xFF"
		"\xFF\x51\x6A\x01\xC7\x45\xF0\x00\x00\x00\x00\x33\xDB\xC7\x45\x08\x00\x00\x00\x00\xFF\xD0\x83\xFF\x02\x7C\x18\x8D\x45\xCC\xC7\x45"
		"\xCC\x5B\x57\x48\x5D\x50\xC7\x45\xD0\x20\x4C\x4C\x0A\x88\x5D\xD4\xFF\x55\xF4\x8D\x46\x20\x50\xFF\x55\x84\x89\x45\xE8\x85\xC0\x0F"
		"\x84\xB1\x00\x00\x00\x83\xFF\x02\x7C\x1E\x8D\x45\xB4\xC7\x45\xB4\x5B\x57\x48\x5D\x50\xC7\x45\xB8\x20\x47\x50\x41\x66\xC7\x45\xBC"
		"\x0A\x00\xFF\x55\xF4\x8B\x45\xE8\x8D\x4D\xA8\x51\x50\xFF\x55\xE0\x89\x45\x80\x85\xC0\x74\x68\x83\xFF\x02\x7C\x1B\x8D\x45\xC0\xC7"
		"\x45\xC0\x5B\x57\x48\x5D\x50\xC7\x45\xC4\x20\x49\x49\x0A\x88\x5D\xC8\xFF\x55\xF4\x8B\x45\x80\xFF\x76\x18\xC7\x45\xF0\x01\x00\x00"
		"\x00\xFF\x76\x10\xFF\x76\x0C\xFF\xD0\x83\xC4\x0C\x89\x45\x08\x83\xFF\x02\x7C\x30\x85\xC0\xC7\x45\x9C\x5B\x57\x48\x5D\xC7\x45\xA0"
		"\x20\x49\x49\x3A\x0F\x95\xC0\xC6\x45\xA4\x20\x04\x30\x66\xC7\x45\xA6\x0A\x00\x88\x45\xA5\x8D\x45\x9C\x50\xFF\x55\xF4\xEB\x05\xFF"
		"\x55\xF8\x8B\xD8\xFF\x75\xE8\xFF\x55\xDC\x83\x7D\x08\x00\x0F\x85\xF6\x00\x00\x00\xEB\x05\xFF\x55\xF8\x8B\xD8\x8B\x46\x18\x85\xC0"
		"\x74\x04\x50\xFF\x55\xFC\xFF\x76\x10\xFF\x55\xFC\x83\x7D\xF0\x00\x0F\x85\xD4\x00\x00\x00\x83\xFF\x01\x0F\x8C\xCB\x00\x00\x00\x8B"
		"\xCB\xC7\x45\x88\x5B\x57\x48\x5D\x83\xE1\x0F\xC7\x45\x8C\x20\x45\x52\x52\x83\xF9\x0A\x66\xC7\x45\x90\x3A\x20\x66\xC7\x45\x9A\x0A"
		"\x00\x1A\xC0\x80\xC1\x37\x24\xF9\xC1\xEB\x04\x02\xC1\x8B\xCB\x88\x45\x99\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04"
		"\x37\x02\xC1\x8B\xCB\x88\x45\x98\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\x97\x83\xE1"
		"\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\x96\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24"
		"\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\x95\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\x94"
		"\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\x80\xC1\x37\x24\xF9\xC1\xEB\x04\x02\xC1\x83\xFB\x0A\x88\x45\x93\x1A\xC0\x24\xF9\x04\x37\x02\xC3"
		"\x88\x45\x92\x8D\x45\x88\x50\xFF\x55\xF4\x6A\x00\xFF\xB5\x78\xFF\xFF\xFF\xFF\x55\xD8\x8B\x45\x08\x5F\x5E\x5B\x8B\xE5\x5D\xC2\x04"
		"\x00\x5F\x5E\x33\xC0\x5B\x8B\xE5\x5D\xC2\x04\x00";

	constexpr SIZE_T x32APCShellcodeSize = sizeof(x32APCShellcode) - 1;

	const BYTE* x32Shellcode = x32APCShellcode + sizeof(PRE_X32SHELLCODE_ARGS_3_TO_1) - 1;
	constexpr SIZE_T x32ShellcodeSize = (sizeof(x32APCShellcode) - 1) - (sizeof(PRE_X32SHELLCODE_ARGS_3_TO_1) - 1);

#define PRE_X64SHELLCODE_VIRTUAL_FREE \
	"\x53"                         /* push rbx                       */ \
	"\x48\x83\xEC\x20"             /* sub rsp,20                     */ \
	"\x48\x8B\xD9"                 /* mov rbx,rcx                    */ \
	"\xE8\x20\x00\x00\x00"         /* call $+20                      */ \
	"\x4C\x8B\x0B"                 /* mov r9,qword ptr ds:[rbx]      */ \
	"\x48\x83\xC4\x20"             /* add rsp,20                     */ \
	"\x5B"                         /* pop rbx                        */ \
	"\x4D\x85\xC9"                 /* test r9,r9                     */ \
	"\x75\x01"                     /* jne $+1                        */ \
	"\xC3"                         /* ret                            */ \
	"\x48\x8D\x0D\xDE\xFF\xFF\xFF" /* lea rcx,qword ptr ds:[<start>] */ \
	"\x33\xD2"                     /* xor edx,edx                    */ \
	"\x41\xB8\x00\x80\x00\x00"     /* mov r8d,8000                   */ \
	"\x41\xFF\xE1"                 /* jmp r9                         */

	// The 64-bit InjectShellcode function from the project in the inject-shellcode subfolder.
	const BYTE x64Shellcode[] =
		PRE_X64SHELLCODE_VIRTUAL_FREE
		"\x48\x89\x4C\x24\x08\x55\x53\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\x6C\x24\xE1\x48\x81\xEC\xC8\x00\x00\x00\xC7\x45\xA7"
		"\x49\x6E\x6A\x65\x48\x8B\xD1\x33\xC9\xC7\x45\xAB\x63\x74\x49\x6E\x66\xC7\x45\xAF\x69\x74\x44\x8B\xD1\xC6\x45\xB1\x00\x44\x8B\xD9"
		"\x65\x48\x8B\x04\x25\x60\x00\x00\x00\x8B\xD9\x48\x89\x4D\xFF\x8B\xF1\x48\x89\x4D\x7F\x44\x8B\xE9\x48\x89\x4D\xE7\x44\x8B\xE1\x48"
		"\x8B\x40\x18\x44\x8B\xF9\x48\x83\xC0\x20\x48\x89\x4D\xEF\x48\x89\x4D\xF7\x44\x8B\xF1\x48\x89\x4D\xDF\x48\x89\x45\x07\x48\x8B\x38"
		"\x48\x89\x7D\x77\x48\x3B\xF8\x0F\x84\x01\x02\x00\x00\x0F\x1F\x00\x4C\x8B\x47\x50\x48\x8B\xD1\x44\x0F\xB7\x4F\x48\xBF\xFF\xFF\x00"
		"\x00\x0F\x1F\x40\x00\x66\x66\x66\x0F\x1F\x84\x00\x00\x00\x00\x00\x41\x0F\xB6\x08\x4D\x8D\x40\x01\xC1\xCA\x0D\x8B\xC2\x48\x03\xC1"
		"\x80\xF9\x61\x48\x8D\x50\xE0\x48\x0F\x42\xD0\x66\x44\x03\xCF\x75\xDF\x48\x8B\x7D\x77\x81\xFA\x5B\xBC\x4A\x6A\x0F\x85\x69\x01\x00"
		"\x00\x4C\x8B\x4F\x20\xBF\x08\x00\x00\x00\x49\x63\x41\x3C\x42\x8B\x84\x08\x88\x00\x00\x00\x49\x03\xC1\x48\x89\x45\xDF\x44\x8B\x50"
		"\x20\x44\x8B\x58\x24\x4D\x03\xD1\x8B\x58\x18\x4D\x03\xD9\x66\x90\x85\xDB\x0F\x84\x1A\x01\x00\x00\x41\x8B\x12\x49\x03\xD1\x33\xC0"
		"\x0F\xB6\x0A\x0F\x1F\x40\x00\x66\x0F\x1F\x84\x00\x00\x00\x00\x00\xC1\xC8\x0D\x48\x8D\x52\x01\x0F\xBE\xC9\x03\xC1\x0F\xB6\x0A\x84"
		"\xC9\x75\xED\x3D\xA4\x4E\x0E\xEC\x74\x35\x3D\xAA\xFC\x0D\x7C\x74\x2E\x3D\xA0\xD5\xC9\x4D\x74\x27\x3D\xAC\x33\x06\x03\x74\x20\x3D"
		"\x66\x19\xDA\x75\x74\x19\x3D\xBC\x22\x0D\x47\x74\x12\x3D\xFB\x97\xFD\x0F\x74\x0B\x3D\x7C\xC4\x22\x59\x0F\x85\xA0\x00\x00\x00\x48"
		"\x8B\x4D\xDF\x45\x0F\xB7\x03\x8B\x51\x1C\x49\x03\xD1\x3D\xA4\x4E\x0E\xEC\x75\x0D\x42\x8B\x04\x82\x49\x03\xC1\x48\x89\x45\x7F\xEB"
		"\x76\x3D\xAA\xFC\x0D\x7C\x75\x0D\x42\x8B\x04\x82\x49\x03\xC1\x48\x89\x45\xE7\xEB\x62\x3D\xA0\xD5\xC9\x4D\x75\x0D\x42\x8B\x04\x82"
		"\x49\x03\xC1\x48\x89\x45\xEF\xEB\x4E\x3D\xAC\x33\x06\x03\x75\x09\x42\x8B\x34\x82\x49\x03\xF1\xEB\x3E\x3D\x66\x19\xDA\x75\x75\x09"
		"\x46\x8B\x2C\x82\x4D\x03\xE9\xEB\x2E\x3D\xBC\x22\x0D\x47\x75\x09\x46\x8B\x24\x82\x4D\x03\xE1\xEB\x1E\x3D\xFB\x97\xFD\x0F\x75\x09"
		"\x46\x8B\x3C\x82\x4D\x03\xF9\xEB\x0E\x3D\x7C\xC4\x22\x59\x75\x07\x46\x8B\x34\x82\x4D\x03\xF1\xB8\xFF\xFF\x00\x00\x66\x03\xF8\x49"
		"\x83\xC2\x04\x49\x83\xC3\x02\xFF\xCB\x66\x85\xFF\x0F\x85\xDE\xFE\xFF\xFF\x4C\x8B\x55\x7F\x4C\x8B\x5D\xE7\x48\x8B\x5D\xEF\x48\x8B"
		"\x7D\x77\x4C\x89\x75\xDF\x4C\x89\x7D\xF7\x4D\x85\xD2\x74\x23\x4D\x85\xDB\x74\x1E\x48\x85\xDB\x74\x19\x48\x85\xF6\x74\x14\x4D\x85"
		"\xED\x74\x0F\x4D\x85\xE4\x74\x0A\x4D\x85\xFF\x74\x05\x4D\x85\xF6\x75\x16\x48\x8B\x3F\xB9\x00\x00\x00\x00\x48\x89\x7D\x77\x48\x3B"
		"\x7D\x07\x0F\x85\x08\xFE\xFF\xFF\x48\x8B\x55\x67\x33\xC9\x48\x89\x32\x4D\x85\xD2\x0F\x84\x4E\x02\x00\x00\x4D\x85\xDB\x0F\x84\x45"
		"\x02\x00\x00\x48\x85\xDB\x0F\x84\x3C\x02\x00\x00\x48\x85\xF6\x0F\x84\x33\x02\x00\x00\x4D\x85\xED\x0F\x84\x2A\x02\x00\x00\x4D\x85"
		"\xE4\x0F\x84\x21\x02\x00\x00\x4D\x85\xFF\x0F\x84\x18\x02\x00\x00\x4D\x85\xF6\x0F\x84\x0F\x02\x00\x00\x8B\x5A\x08\x8B\xF1\x8B\xF9"
		"\x48\x8D\x55\x6F\xB9\x01\x00\x00\x00\x41\xFF\xD6\x83\xFB\x02\x7C\x1D\x48\x8D\x4C\x24\x20\xC7\x44\x24\x20\x5B\x57\x48\x5D\xC7\x44"
		"\x24\x24\x20\x4C\x4C\x0A\xC6\x44\x24\x28\x00\x41\xFF\xD4\x48\x8B\x4D\x67\x48\x83\xC1\x20\xFF\x55\x7F\x4C\x8B\xF0\x48\x85\xC0\x0F"
		"\x84\xB5\x00\x00\x00\x83\xFB\x02\x7C\x1B\x48\x8D\x4D\x97\xC7\x45\x97\x5B\x57\x48\x5D\xC7\x45\x9B\x20\x47\x50\x41\x66\xC7\x45\x9F"
		"\x0A\x00\x41\xFF\xD4\x48\x8D\x55\xA7\x49\x8B\xCE\xFF\x55\xE7\x4C\x8B\xF8\x48\x85\xC0\x74\x6A\x83\xFB\x02\x7C\x19\x48\x8D\x4D\x87"
		"\xC7\x45\x87\x5B\x57\x48\x5D\xC7\x45\x8B\x20\x49\x49\x0A\xC6\x45\x8F\x00\x41\xFF\xD4\x48\x8B\x45\x67\xC7\x45\xFF\x01\x00\x00\x00"
		"\x4C\x8B\x40\x18\x48\x8B\x50\x10\x8B\x48\x0C\x41\xFF\xD7\x8B\xF0\x83\xFB\x02\x7C\x31\x85\xC0\xC7\x45\xB7\x5B\x57\x48\x5D\xC7\x45"
		"\xBB\x20\x49\x49\x3A\x0F\x95\xC1\xC6\x45\xBF\x20\x80\xC1\x30\x66\xC7\x45\xC1\x0A\x00\x88\x4D\xC0\x48\x8D\x4D\xB7\x41\xFF\xD4\xEB"
		"\x05\x41\xFF\xD5\x8B\xF8\x49\x8B\xCE\xFF\x55\xEF\x85\xF6\x0F\x85\x08\x01\x00\x00\x4C\x8B\x7D\xF7\xEB\x05\x41\xFF\xD5\x8B\xF8\x4C"
		"\x8B\x75\x67\x49\x8B\x4E\x18\x48\x85\xC9\x74\x03\x41\xFF\xD7\x49\x8B\x4E\x10\x41\xFF\xD7\x83\x7D\xFF\x00\x0F\x85\xDC\x00\x00\x00"
		"\x83\xFB\x01\x0F\x8C\xD3\x00\x00\x00\x8B\xCF\xC7\x45\xC7\x5B\x57\x48\x5D\x83\xE1\x0F\xC7\x45\xCB\x20\x45\x52\x52\x83\xF9\x0A\x66"
		"\xC7\x45\xCF\x3A\x20\xBA\x30\x00\x00\x00\x66\xC7\x45\xD9\x0A\x00\x41\xB8\x37\x00\x00\x00\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02"
		"\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xD8\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xD7\x83"
		"\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xD6\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF"
		"\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xD5\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45"
		"\xD4\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xD3\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0"
		"\xC1\xEF\x04\x02\xC1\x48\x8D\x4D\xC7\x83\xFF\x0A\x88\x45\xD2\x41\x0F\x43\xD0\x40\x02\xD7\x88\x55\xD1\x41\xFF\xD4\x8B\x4D\x6F\x33"
		"\xD2\xFF\x55\xDF\x8B\xC6\xEB\x02\x33\xC0\x48\x81\xC4\xC8\x00\x00\x00\x41\x5F\x41\x5E\x41\x5D\x41\x5C\x5F\x5E\x5B\x5D\xC3";

	constexpr SIZE_T x64ShellcodeSize = sizeof(x64Shellcode) - 1;

	//
	// https://docs.microsoft.com/en-us/windows/win32/sysinfo/verifying-the-system-version
	//
	BOOL CheckWindowsVersion(DWORD dwMajorVersion, DWORD dwMinorVersion,
		WORD wServicePackMajor, WORD wServicePackMinor, int op)
	{
		// Initialize the OSVERSIONINFOEX structure
		OSVERSIONINFOEX osvi;

		ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
		osvi.dwMajorVersion = dwMajorVersion;
		osvi.dwMinorVersion = dwMinorVersion;
		osvi.wServicePackMajor = wServicePackMajor;
		osvi.wServicePackMinor = wServicePackMinor;

		// Initialize the type mask
		DWORD dwTypeMask = VER_MAJORVERSION | VER_MINORVERSION |
			VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR;

		// Initialize the condition mask
		DWORDLONG dwlConditionMask = 0;

		VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, op);
		VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, op);
		VER_SET_CONDITION(dwlConditionMask, VER_SERVICEPACKMAJOR, op);
		VER_SET_CONDITION(dwlConditionMask, VER_SERVICEPACKMINOR, op);

		// Perform the test
		return VerifyVersionInfo(&osvi, dwTypeMask, dwlConditionMask);
	}

	//
	// Based on:
	// http://securityxploded.com/ntcreatethreadex.php
	//
	HANDLE MyCreateRemoteThread(HANDLE hProcess,
		LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, USHORT targetProcessArch)
	{
#ifndef _WIN64
		if (targetProcessArch == IMAGE_FILE_MACHINE_AMD64) {
			// WOW64 to x64 native, use heaven's gate.
			return (HANDLE)CreateRemoteThread64(
				HANDLE_TO_DWORD64(hProcess), PTR_TO_DWORD64(lpStartAddress), PTR_TO_DWORD64(lpParameter));
		}
#endif // _WIN64

		using NtCreateThreadEx_t = NTSTATUS(WINAPI*)(
			OUT PHANDLE hThread,
			IN ACCESS_MASK DesiredAccess,
			IN LPVOID ObjectAttributes,
			IN HANDLE ProcessHandle,
			IN LPTHREAD_START_ROUTINE lpStartAddress,
			IN LPVOID lpParameter,
			IN BOOL CreateSuspended,
			IN ULONG_PTR StackZeroBits,
			IN ULONG_PTR SizeOfStackCommit,
			IN ULONG_PTR SizeOfStackReserve,
			OUT LPVOID lpBytesBuffer
			);

		static NtCreateThreadEx_t pNtCreateThreadEx = []() {
			// Only needed for Windows Vista and 7.
			if (CheckWindowsVersion(6, 0, 0, 0, VER_GREATER_EQUAL) &&
				!CheckWindowsVersion(6, 2, 0, 0, VER_GREATER_EQUAL)) {
				HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
				if (hNtdll) {
					return (NtCreateThreadEx_t)GetProcAddress(hNtdll, "NtCreateThreadEx");
				}
			}

			return (NtCreateThreadEx_t)nullptr;
		}();

		LPSECURITY_ATTRIBUTES lpThreadAttributes = nullptr;
		DWORD dwCreationFlags = 0;

		if (pNtCreateThreadEx) {
			HANDLE hThread;
			ULONG_PTR bOutBuffer1[2];
			ULONG_PTR bOutBuffer2[1];
			struct {
				ULONG_PTR Size;
				ULONG_PTR Unknown1;
				ULONG_PTR nBuf1Size;
				void* pBuf1;
				ULONG_PTR Unknown2;
				ULONG_PTR Unknown3;
				ULONG_PTR nBuf2Size;
				void* pBuf2;
				ULONG_PTR Unknown4;
			} param = { sizeof(param), 0x10003, sizeof(ULONG_PTR) * 2, bOutBuffer1, 0, 0x10004, sizeof(ULONG_PTR), bOutBuffer2, 0 };

			NTSTATUS result = pNtCreateThreadEx(&hThread, 0x1FFFFF, lpThreadAttributes,
				hProcess, lpStartAddress, lpParameter, (dwCreationFlags & CREATE_SUSPENDED) ? TRUE : FALSE, 0, 0, 0, &param);
			if (result < 0) {
				SetLastError(LsaNtStatusToWinError(result));
				return nullptr;
			}

			return hThread;
		}

		return CreateRemoteThread(hProcess, lpThreadAttributes, 0, lpStartAddress, lpParameter, dwCreationFlags, nullptr);
	}

	//
	// Reference: https://repnz.github.io/posts/apc/wow64-user-apc/
	//
	ULONG64 EncodeWow64ApcRoutine(ULONG64 ApcRoutine)
	{
		return (ULONG64)((-(INT64)ApcRoutine) << 2);
	}

	//
	// Reference: https://repnz.github.io/posts/apc/user-apc/
	//
	BOOL MyQueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData, USHORT targetProcessArch)
	{
#ifndef _WIN64
		if (targetProcessArch == IMAGE_FILE_MACHINE_AMD64) {
			// WOW64 to x64 native, use heaven's gate.
			//
			// "Microsoft added a validation to prevent a programming error:
			// If you try to queue an APC from a 32 bit process to a 64 bit
			// process and you use a 32 bit address, you'll get this status code:
			// [...] STATUS_INVALID_HANDLE"
			// https://repnz.github.io/posts/apc/wow64-user-apc/
			return NtQueueApcThread64(
				HANDLE_TO_DWORD64(hThread), PTR_TO_DWORD64(pfnAPC), (DWORD64)dwData, 0, 0);
		}
#endif // _WIN64

		using NtQueueApcThread_t = DWORD(WINAPI*)(
			IN HANDLE ThreadHandle,
			IN PVOID ApcDispatchRoutine,
			IN ULONG_PTR SystemArgument1,
			IN ULONG_PTR SystemArgument2,
			IN ULONG_PTR SystemArgument3
			);

		static NtQueueApcThread_t pNtQueueApcThread = []() {
			HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
			if (hNtdll) {
				return (NtQueueApcThread_t)GetProcAddress(hNtdll, "NtQueueApcThread");
			}

			return (NtQueueApcThread_t)nullptr;
		}();

		if (!pNtQueueApcThread) {
			SetLastError(ERROR_PROC_NOT_FOUND);
			return FALSE;
		}

#ifdef _WIN64
		if (targetProcessArch == IMAGE_FILE_MACHINE_I386) {
			// x64 native to WOW64, encode address.
			pfnAPC = (PAPCFUNC)EncodeWow64ApcRoutine((ULONG64)pfnAPC);
		}
#endif // _WIN64

		NTSTATUS result = pNtQueueApcThread(hThread, pfnAPC, dwData, 0, 0);
		if (result < 0) {
			SetLastError(LsaNtStatusToWinError(result));
			return FALSE;
		}

		return TRUE;
	}

	USHORT GetProcessArch(HANDLE hProcess)
	{
		// For now, only IMAGE_FILE_MACHINE_I386 and IMAGE_FILE_MACHINE_AMD64.
		// TODO: Use IsWow64Process2 if available.

#ifndef _WIN64
		SYSTEM_INFO siSystemInfo;
		GetNativeSystemInfo(&siSystemInfo);
		if (siSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
			// 32-bit machine, only one option.
			return IMAGE_FILE_MACHINE_I386;
		}
#endif // _WIN64

		BOOL bIsWow64Process;
		if (IsWow64Process(hProcess, &bIsWow64Process) && bIsWow64Process) {
			return IMAGE_FILE_MACHINE_I386;
		}

		return IMAGE_FILE_MACHINE_AMD64;
	}

	std::filesystem::path GetEnginePath(USHORT machine)
	{
		std::filesystem::path libraryPath = wil::GetModuleFileName<std::wstring>(g_hDllInst);

		auto folderPath = libraryPath.parent_path();
		auto folderName = folderPath.filename();

		if (folderName != L"32" && folderName != L"64") {
			throw std::runtime_error("DLL file not in \\32 or \\64 folder");
		}

		PCWSTR newFolderName;
		switch (machine) {
		case IMAGE_FILE_MACHINE_I386:
			newFolderName = L"32";
			break;

		case IMAGE_FILE_MACHINE_AMD64:
			newFolderName = L"64";
			break;

		default:
			throw std::logic_error("Unknown architecture");
		}

		return folderPath.parent_path() / newFolderName;
	}
}

namespace DllInject
{
	void DllInject(HANDLE hProcess, HANDLE hThreadForAPC, HANDLE hSessionManagerProcess, HANDLE hSessionMutex)
	{
		const BYTE* shellcode;
		size_t shellcodeSize;

		USHORT targetProcessArch = GetProcessArch(hProcess);
		switch (targetProcessArch) {
		case IMAGE_FILE_MACHINE_I386:
			if (hThreadForAPC) {
				// The calling convention is different - three arguments instead of one.
				shellcode = x32APCShellcode;
				shellcodeSize = x32APCShellcodeSize;
			}
			else {
				shellcode = x32Shellcode;
				shellcodeSize = x32ShellcodeSize;
			}
			break;

		case IMAGE_FILE_MACHINE_AMD64:
			shellcode = x64Shellcode;
			shellcodeSize = x64ShellcodeSize;
			break;

		default:
			throw std::logic_error("Invalid architecture value");
		}

		std::wstring dllPath = GetEnginePath(targetProcessArch) / L"global-inject-lib.dll";
		size_t dllPathBytes = (dllPath.length() + 1) * sizeof(WCHAR);

		HANDLE hRemoteSessionManagerProcess;
		THROW_IF_WIN32_BOOL_FALSE(DuplicateHandle(GetCurrentProcess(), hSessionManagerProcess, hProcess, &hRemoteSessionManagerProcess,
			PROCESS_DUP_HANDLE | PROCESS_QUERY_LIMITED_INFORMATION | SYNCHRONIZE, FALSE, 0));

		auto remoteSessionManagerProcessCleanup = wil::scope_exit([hProcess, hRemoteSessionManagerProcess] {
			DuplicateHandle(hProcess, hRemoteSessionManagerProcess, nullptr, nullptr, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
		});

		HANDLE hRemoteSessionMutex = nullptr;
		if (hSessionMutex) {
			THROW_IF_WIN32_BOOL_FALSE(DuplicateHandle(GetCurrentProcess(), hSessionMutex, hProcess, &hRemoteSessionMutex,
				PROCESS_QUERY_LIMITED_INFORMATION, FALSE, 0));
		}

		auto remoteSessionMutexCleanup = wil::scope_exit([hProcess, hRemoteSessionMutex] {
			if (hRemoteSessionMutex) {
				DuplicateHandle(hProcess, hRemoteSessionMutex, nullptr, nullptr, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
			}
		});

		size_t shellcodeDataSize = offsetof(LOAD_LIBRARY_REMOTE_DATA, szDllName) + dllPathBytes;
		auto shellcodeDataVector = std::vector<BYTE>(shellcodeDataSize);
		auto shellcodeData = reinterpret_cast<LOAD_LIBRARY_REMOTE_DATA*>(shellcodeDataVector.data());

		shellcodeData->nLogVerbosity = 2;
		shellcodeData->bRunningFromAPC = !!hThreadForAPC;
		shellcodeData->hSessionManagerProcess = hRemoteSessionManagerProcess;
		shellcodeData->hSessionMutex = hRemoteSessionMutex;
		memcpy(shellcodeData->szDllName, dllPath.c_str(), dllPathBytes);

		size_t shellcodeSizeAligned = (shellcodeSize + (sizeof(LONG_PTR) - 1)) & ~(sizeof(LONG_PTR) - 1);

		// Allocate enough memory in the remote process's address space
		// to hold the shellcode and the data struct.
		void* pRemoteCode = VirtualAllocEx(
			hProcess, nullptr, shellcodeSizeAligned + shellcodeDataSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		THROW_LAST_ERROR_IF_NULL(pRemoteCode);

		auto remoteCodeCleanup = wil::scope_exit([hProcess, pRemoteCode] {
			VirtualFreeEx(hProcess, pRemoteCode, 0, MEM_RELEASE);
		});

		// Write our shellcode into the remote process.
		THROW_IF_WIN32_BOOL_FALSE(WriteProcessMemory(hProcess, pRemoteCode, shellcode, shellcodeSize, nullptr));

		// Write a copy of our struct to the remote process.
		void* pRemoteData = reinterpret_cast<BYTE*>(pRemoteCode) + shellcodeSizeAligned;
		THROW_IF_WIN32_BOOL_FALSE(WriteProcessMemory(hProcess, pRemoteData, shellcodeData, shellcodeDataSize, nullptr));

		if (hThreadForAPC) {
			THROW_IF_WIN32_BOOL_FALSE(MyQueueUserAPC(
				reinterpret_cast<PAPCFUNC>(pRemoteCode), hThreadForAPC, reinterpret_cast<ULONG_PTR>(pRemoteData), targetProcessArch));
		}
		else {
			wil::unique_process_handle hRemoteThread(MyCreateRemoteThread(hProcess,
				reinterpret_cast<LPTHREAD_START_ROUTINE>(pRemoteCode), pRemoteData, targetProcessArch));
			THROW_LAST_ERROR_IF_NULL(hRemoteThread);
		}

		remoteSessionManagerProcessCleanup.release();
		remoteSessionMutexCleanup.release();
		remoteCodeCleanup.release();
	}
}
